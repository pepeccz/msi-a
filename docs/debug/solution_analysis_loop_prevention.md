# Solution Analysis: Loop Prevention Strategy

**Date**: 2026-01-31  
**Issue**: Prevent `finalizar_expediente` loop without breaking design intent  
**Approach**: Idempotency check instead of `terminate_processing`

---

## Executive Summary

**Decision**: Implement idempotency check in `finalizar_expediente` WITHOUT adding `terminate_processing: True`.

**Reasoning**: Adding `terminate_processing` would contradict the explicit design intent that the bot should remain active after case finalization to handle follow-up questions.

---

## Design Intent Analysis

### Evidence from Code

**Comment in `case_tools.py` line 1359:**
```python
# Reset FSM (bot stays active for further consultations)
```

**User-facing message (lines 1364-1368):**
```python
"¡Perfecto! Tu expediente ha sido enviado para revisión.\n\n"
"Un agente de MSI Automotive lo revisará y se pondrá en contacto "
"contigo a la mayor brevedad posible.\n\n"
"Mientras tanto, si tienes alguna otra consulta, estaré encantado de ayudarte."
#                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
```

The message explicitly invites the user to continue asking questions, which would be contradictory if the bot terminated processing.

---

## Comparison with Similar Tools

| Tool | Purpose | Bot Disabled? | `terminate_processing`? | Post-Action Use |
|------|---------|---------------|------------------------|-----------------|
| **`escalar_a_humano`** | User needs help NOW | ✅ YES (Chatwoot) | ✅ YES | ❌ Bot off |
| **`finalizar_expediente`** | Case complete, review LATER | ❌ NO | ❌ NO | ✅ Bot active |
| **`cancelar_expediente`** | Cancel, restart | ❌ NO | ❌ NO | ✅ Bot active |

### Key Differences

**`escalar_a_humano`** (urgent escalation):
- Calls `update_conversation_attributes(atencion_automatica=False)` to disable bot in Chatwoot
- Returns `escalation_triggered: True` to prevent future AI responses
- Returns `terminate_processing: True` to exit tool loop
- Webhook rejects future messages (bot disabled)

**`finalizar_expediente`** (async form submission):
- Does NOT disable bot in Chatwoot
- Does NOT return `escalation_triggered`
- Does NOT return `terminate_processing`
- Webhook continues processing messages (bot active)
- User can ask follow-up questions or start new quotes

---

## Why NOT Add `terminate_processing: True`?

### What `terminate_processing` Does

From `conversational_agent.py` lines 1243-1260:

```python
if tool_result.get("terminate_processing"):
    logger.info(
        f"ESCALATION_TERMINATION | Processing terminated by {tool_name} | "
        f"conversation_id={conversation_id}",
        ...
    )
    # Extract user-facing message and exit loop immediately
    ai_content = tool_result.get("result", 
        "Un agente de MSI Automotive se pondrá en contacto contigo lo antes posible."
    )
    should_terminate = True
    break  # Exit tool loop - don't process more tools
```

**Effects:**
1. Immediately exits tool execution loop (no more tools called in this iteration)
2. Uses tool's message as final response (no LLM generation after)
3. **Does NOT prevent future messages** (bot stays active)
4. **Does NOT set `escalation_triggered` in state** (unless tool also returns that flag)

### What WOULD Break

| Aspect | Current Behavior | With `terminate_processing: True` |
|--------|------------------|-----------------------------------|
| **FSM Reset** | ✅ Returns to IDLE | ✅ Returns to IDLE |
| **Bot Response** | ✅ Generated by LLM with tool result | ❌ Uses tool's `message` field directly (no LLM) |
| **Tool Loop** | ✅ Continues if LLM calls more tools | ❌ Immediately exits (no more tools) |
| **Future Messages** | ✅ Bot active, FSM in IDLE, can answer questions | ✅ Bot active, FSM in IDLE, can answer questions |
| **User Experience** | ✅ Natural conversation continues | ⚠️ Abrupt termination (but bot stays active) |

**Problems:**
1. **No LLM generation**: The tool's message is used verbatim, preventing the LLM from adding context or natural tone
2. **Prevents follow-up tool calls**: If the LLM wanted to call another tool (e.g., for a follow-up question), it can't in the same iteration
3. **Inconsistent with design**: The message says "estaré encantado de ayudarte" but the behavior suggests finality

---

## Chosen Solution: Idempotency Check

### Implementation

**Added to `case_tools.py` at line 1331-1356:**

```python
# Idempotency check: if already finalized, return success without re-processing
if case.status == "pending_review":
    logger.info(
        f"Case already finalized (idempotent call): case_id={case_id}",
        extra={
            "case_id": case_id,
            "conversation_id": conversation_id,
            "idempotent": True,
        },
    )
    # Reset FSM even on duplicate call (in case FSM state is stale)
    new_fsm_state = reset_fsm(fsm_state)
    
    return {
        "success": True,
        "already_finalized": True,
        "message": (
            "Tu expediente ya fue enviado para revisión.\n\n"
            "Un agente de MSI Automotive lo revisará y se pondrá en contacto "
            "contigo a la mayor brevedad posible.\n\n"
            "Mientras tanto, si tienes alguna otra consulta, estaré encantado de ayudarte."
        ),
        "case_id": case_id,
        "next_step": CollectionStep.COMPLETED.value,
        "fsm_state_update": new_fsm_state,
    }
```

### How It Works

**First call**:
1. Case status is `active` (or similar)
2. Idempotency check passes (status != `pending_review`)
3. Proceeds with finalization
4. Sets `case.status = "pending_review"`
5. Commits to database
6. Returns success

**Second call (same or different turn)**:
1. Case status is NOW `pending_review` (from first call)
2. Idempotency check detects this
3. Returns immediately with `already_finalized: True`
4. Does NOT modify database
5. Resets FSM (in case stale)
6. Same user message (consistent UX)

### Why This Works

**Timing-Independent**:
- Works across turns (database is already committed from first call)
- Works within same turn (though less likely due to prompt fix)

**Database as Source of Truth**:
- FSM state is local to each invocation and resets
- Database status persists across invocations
- First call commits `pending_review` status
- Second call sees the committed status

**Maintains Design Intent**:
- Bot stays active
- LLM can still generate natural responses
- No abrupt termination
- Consistent with `cancelar_expediente` pattern

---

## Defense in Depth

The loop prevention now has **three layers**:

### Layer 1: Prompt-Level Rule (Already Implemented)

**File**: `agent/prompts/phases/review_summary.md` (lines 32-35)

```markdown
**Si devuelve `success: true`:**
- Usa el campo `message` EXACTO (no lo parafrasees)
- DETENTE. No hagas nada mas
- NO vuelvas a llamar la herramienta
```

**Effect**: Guides LLM behavior (soft guard)

### Layer 2: Idempotency Check (NEW - This PR)

**File**: `agent/tools/case_tools.py` (lines 1331-1356)

**Effect**: 
- If LLM ignores prompt and calls tool again
- Database check catches it
- Returns success without re-processing
- Hard guard (code-level)

### Layer 3: Loop Detection (Existing)

**File**: `agent/nodes/conversational_agent.py` (lines 1078-1150)

**Effect**:
- If tool called 3 times with identical args
- Auto-escalation triggered
- Processing terminated
- Fallback safety net

---

## Testing Plan

### Test Case 1: Normal Flow (No Duplicate)

**Setup**: Case at REVIEW_SUMMARY

**Steps**:
1. User confirms: "Si"
2. Agent calls `finalizar_expediente()`
3. Tool checks DB: `case.status != "pending_review"` → proceed
4. Tool sets `case.status = "pending_review"`
5. Tool returns success
6. Agent sends message to user

**Expected**:
- ✅ Case finalized once
- ✅ Database updated once
- ✅ User receives confirmation message
- ✅ Bot remains active

**Pass Criteria**: Exactly 1 database update

---

### Test Case 2: Duplicate Call (Same Turn)

**Setup**: Case at REVIEW_SUMMARY, LLM ignores prompt and calls tool twice in same iteration

**Steps**:
1. User confirms: "Si"
2. Agent calls `finalizar_expediente()` (iteration 1)
3. Tool checks DB: `case.status != "pending_review"` → proceed
4. Tool sets `case.status = "pending_review"`, commits
5. Tool returns success
6. LLM (ignoring prompt) calls `finalizar_expediente()` again (iteration 2)
7. Tool checks DB: `case.status == "pending_review"` → idempotent return
8. Tool returns success with `already_finalized: True`

**Expected**:
- ✅ Case finalized once
- ✅ Database updated once (first call)
- ✅ Second call returns immediately (no DB update)
- ✅ Log shows `"idempotent": True` for second call
- ✅ User receives confirmation message

**Pass Criteria**: 
- Database updated exactly once
- Second call logged as idempotent
- No error or escalation

---

### Test Case 3: Duplicate Call (Different Turn)

**Setup**: Case finalized in previous turn, user sends new message, LLM calls `finalizar_expediente` again

**Steps**:
1. **Turn 1**: User confirms, case finalized
2. **Turn 2**: User sends "Gracias"
3. LLM (mistakenly) calls `finalizar_expediente()`
4. Tool checks DB: `case.status == "pending_review"` → idempotent return
5. Tool returns success with `already_finalized: True`
6. Agent responds naturally

**Expected**:
- ✅ No database update
- ✅ Tool returns success (not error)
- ✅ Log shows idempotent call
- ✅ Bot continues conversation normally

**Pass Criteria**: No database modification, bot stays active

---

## Comparison: Alternative Solutions Rejected

### Alternative A: `terminate_processing: True`

**Why Rejected**: Contradicts design intent

| Pro | Con |
|-----|-----|
| ✅ Stops tool loop immediately | ❌ Prevents LLM from generating natural responses |
| ✅ Uses existing infrastructure | ❌ Abrupt termination inconsistent with message |
| ✅ 100% deterministic | ❌ Breaks post-finalization consultations |
|  | ❌ Requires also disabling Chatwoot bot to be consistent |

**Verdict**: Would require redesigning the entire post-finalization flow.

---

### Alternative B: Lower Loop Detection Threshold

**Current**: `LOOP_DETECTION_THRESHOLD = 2` (triggers on 3rd call)

**Proposed**: `LOOP_DETECTION_THRESHOLD = 1` (triggers on 2nd call)

**Why Rejected**: Too aggressive, may cause false positives

| Pro | Con |
|-----|-----|
| ✅ Faster loop detection | ❌ Some tools legitimately called twice |
| ✅ 1-line change | ❌ Only mitigates, doesn't prevent |
| ✅ Benefits all tools | ❌ Still allows 2 database updates |

**Verdict**: Good complementary measure, but not a root solution.

---

### Alternative C: Inject System Message After Success

**Proposed**: After `finalizar_expediente` success, inject:

```python
llm_messages.append(SystemMessage(content=(
    "OPERACIÓN COMPLETADA. El expediente ha sido finalizado exitosamente. "
    "Responde al usuario con el mensaje de la herramienta EXACTO y no hagas nada más."
)))
```

**Why Rejected**: Soft guard, not deterministic

| Pro | Con |
|-----|-----|
| ✅ Reinforces signal to LLM | ❌ Depends on LLM compliance (soft guard) |
| ✅ Dynamic injection | ❌ Adds ~40 tokens per finalization |
| ✅ Works for any terminal tool | ❌ No guarantee LLM will obey |

**Verdict**: Good complement to prompt rule, but not a hard guard.

---

## Monitoring

### Metrics to Track

| Metric | How to Measure | Alert Threshold |
|--------|----------------|-----------------|
| **Idempotent finalizations** | Count `already_finalized: True` returns | >5% of finalizations |
| **Multiple finalizar_expediente calls** | Count conversations with >1 call | >1% of conversations |
| **Loop escalations (finalizar)** | Count escalations with `tool_name=finalizar_expediente` | >0 per day |

### Log Queries

```sql
-- Count idempotent finalization calls (last 7 days)
SELECT 
  COUNT(*) as idempotent_count,
  COUNT(*) * 100.0 / NULLIF((
    SELECT COUNT(*) 
    FROM tool_call_logs 
    WHERE tool_name = 'finalizar_expediente' 
      AND created_at > NOW() - INTERVAL '7 days'
  ), 0) as percentage
FROM tool_call_logs
WHERE tool_name = 'finalizar_expediente'
  AND result::text LIKE '%already_finalized%'
  AND created_at > NOW() - INTERVAL '7 days';

-- Find conversations with multiple finalizar_expediente calls
SELECT 
  conversation_id,
  COUNT(*) as call_count,
  MIN(created_at) as first_call,
  MAX(created_at) as last_call,
  EXTRACT(EPOCH FROM (MAX(created_at) - MIN(created_at))) as seconds_apart
FROM tool_call_logs
WHERE tool_name = 'finalizar_expediente'
  AND created_at > NOW() - INTERVAL '7 days'
GROUP BY conversation_id
HAVING COUNT(*) > 1
ORDER BY call_count DESC, seconds_apart ASC;
```

---

## Success Criteria

### Immediate (After Deployment)

- [ ] Zero database duplicate updates for same case
- [ ] Idempotent calls logged with `"idempotent": True`
- [ ] No escalations triggered by `finalizar_expediente` loops
- [ ] Bot remains active after finalization (responds to follow-up questions)

### 7-Day Window

- [ ] <5% of finalizations are idempotent calls (indicates rare edge case)
- [ ] <1% of conversations have multiple finalization attempts
- [ ] Zero loop-detection escalations for `finalizar_expediente`
- [ ] User satisfaction maintains or improves (post-finalization NPS)

### 30-Day Window

- [ ] Finalization loop rate: <0.1% (target: 1 per 1000 cases)
- [ ] Idempotent call rate stable or decreasing (prompt guidance working)
- [ ] No regression in other loop patterns (re-confirmation, escalation)

---

## Rollback Plan

### Indicators for Rollback

1. **Idempotent call rate >20%**: Suggests FSM state management issue
2. **Bot stops responding after finalization**: Database check blocking incorrectly
3. **Increase in manual case completions**: Idempotency breaking legitimate retries

### Rollback Procedure

```bash
# 1. Revert the code change
git revert <commit-hash>

# 2. Deploy immediately
docker-compose restart agent

# 3. Verify rollback
docker-compose logs -f agent | grep "finalizar_expediente"

# 4. Check database for stuck cases
psql -U msia msia_db -c "
  SELECT id, status, completed_at 
  FROM cases 
  WHERE status = 'pending_review' 
    AND completed_at IS NULL;
"
```

### Alternative: Disable Idempotency Check (Feature Flag)

If full rollback is too disruptive, add a feature flag:

```python
# In shared/config.py
ENABLE_FINALIZE_IDEMPOTENCY: bool = Field(default=True)

# In case_tools.py
if settings.ENABLE_FINALIZE_IDEMPOTENCY and case.status == "pending_review":
    # Idempotency logic
```

Then disable via environment variable:
```bash
ENABLE_FINALIZE_IDEMPOTENCY=false docker-compose restart agent
```

---

## Related Documentation

- [Root Cause Analysis](./conversation_1_root_cause_analysis.md) - Original bug investigation
- [Fix Summary](./conversation_1_fix_summary.md) - Prompt-level fix (Layer 1)
- [ADR-003](../decisions/003-remove-chatwoot-atencion-check.md) - Escalation architecture

---

## Changelog

| Date | Change | Author |
|------|--------|--------|
| 2026-01-31 | Initial idempotency implementation | Analysis Team |
| 2026-01-31 | Document design intent and alternatives | Analysis Team |

---

**Generated by**: Root Cause Analysis Session  
**Reviewed by**: Architecture Team  
**Approved for**: Production Deployment  
**Risk Level**: Low (maintains existing behavior, adds safety)
